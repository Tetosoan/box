<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sokoban Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #game-container {
            display: grid;
            grid-template-columns: repeat(12, 40px);
            grid-template-rows: repeat(12, 40px);
            gap: 2px;
        }
        .cell { width: 40px; height: 40px; border: 1px solid #ccc; }
        .box { background-color: #FFD700; }
        .goal { background-color: #32CD32; }
        .player { background-color: #1E90FF; }
        .obstacle { background-color: #A9A9A9; }
        #info { margin-bottom: 20px; }
    </style>
</head>
<body>
    <div id="info">
        <h2>Sokoban Game</h2>
        <label for="difficulty">Select Difficulty:</label>
        <select id="difficulty">
            <option value="easy">Easy (4 boxes, 100 moves)</option>
            <option value="medium">Medium (6 boxes, 70 moves)</option>
            <option value="hard">Hard (7 boxes, 60 moves)</option>
        </select>
        <div>Moves: <span id="step-count">0</span> / <span id="remaining-steps">100</span></div>
        <button id="reset-button">Reset Game</button>
    </div>
    <div id="game-container"></div>

    <script>
        const gridSize = 12;
        let playerPos = { x: 0, y: 0 }, boxes = [], goals = [], obstacles = [], stepCount = 0, maxSteps = 100;

        const initGame = () => {
            document.getElementById('game-container').innerHTML = '';
            stepCount = 0;
            boxes = [];
            goals = [];
            obstacles = [];
            playerPos = { x: 0, y: 0 };
            maxSteps = { easy: 100, medium: 70, hard: 60 }[document.getElementById('difficulty').value];

            createGrid();
            placeElements(4, 5); // Default easy mode
        };

        const createGrid = () => {
            const container = document.getElementById('game-container');
            for (let i = 0; i < gridSize * gridSize; i++) {
                container.appendChild(document.createElement('div')).classList.add('cell');
            }
            render();
        };

        const placeElements = (boxCount, goalCount) => {
            placeRandomElements(boxes, boxCount, true);
            placeRandomElements(goals, goalCount);
            placeObstacles();
            render();
        };

        const placeRandomElements = (arr, count, isBox = false) => {
            const minX = isBox ? 1 : 0; // Prevent box placement on the outer edge
            const minY = isBox ? 1 : 0;
            const maxX = gridSize - 2; // Prevent box placement on the outer edge
            const maxY = gridSize - 2; // Prevent box placement on the outer edge

            while (arr.length < count) {
                const pos = { 
                    x: Math.floor(Math.random() * (maxX - minX + 1)) + minX, 
                    y: Math.floor(Math.random() * (maxY - minY + 1)) + minY 
                };
                if (!arr.some(e => e.x === pos.x && e.y === pos.y) && !(pos.x === 0 && pos.y === 0)) {
                    arr.push(pos);
                }
            }
        };

        const placeObstacles = () => {
            while (obstacles.length < 20) {
                const pos = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
                if (!boxes.some(b => b.x === pos.x && b.y === pos.y) && !goals.some(g => g.x === pos.x && g.y === pos.y) && !(pos.x === 0 && pos.y === 0)) {
                    obstacles.push(pos);
                }
            }
        };

        const render = () => {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => cell.className = 'cell');
            boxes.forEach(box => cells[box.y * gridSize + box.x].classList.add('box'));
            goals.forEach(goal => cells[goal.y * gridSize + goal.x].classList.add('goal'));
            cells[playerPos.y * gridSize + playerPos.x].classList.add('player');
            obstacles.forEach(obs => cells[obs.y * gridSize + obs.x].classList.add('obstacle'));
            updateStepCount();
        };

        const updateStepCount = () => {
            document.getElementById('step-count').innerText = stepCount;
            document.getElementById('remaining-steps').innerText = maxSteps - stepCount;
        };

        const movePlayer = (dx, dy) => {
            const newPos = { x: playerPos.x + dx, y: playerPos.y + dy };
            if (isValidMove(newPos)) {
                const boxIndex = boxes.findIndex(b => b.x === newPos.x && b.y === newPos.y);
                if (boxIndex !== -1) {
                    const nextBoxPos = { x: newPos.x + dx, y: newPos.y + dy };
                    if (isValidMove(nextBoxPos) && !isBoxOnGoal(boxIndex)) {
                        boxes[boxIndex] = nextBoxPos;
                    } else return; // Do not move boxes already on the goal
                }
                playerPos = newPos;
                stepCount++;
                render();
                checkWin();
            }
        };

        const isValidMove = (pos) => {
            return pos.x >= 0 && pos.x < gridSize && pos.y >= 0 && pos.y < gridSize &&
                   !obstacles.some(o => o.x === pos.x && o.y === pos.y);
        };

        const isBoxOnGoal = (boxIndex) => {
            const box = boxes[boxIndex];
            return goals.some(goal => box.x === goal.x && box.y === goal.y);
        };

        const checkWin = () => {
            if (boxes.every(box => goals.some(goal => box.x === goal.x && box.y === goal.y))) {
                alert('Congratulations! You completed the game!');
                initGame();
            }
            if (stepCount >= maxSteps) {
                alert('You have reached the maximum number of moves. Game over!');
                initGame();
            }
        };

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
            }
        });

        document.getElementById('reset-button').addEventListener('click', initGame);
        document.getElementById('difficulty').addEventListener('change', initGame);

        initGame();
    </script>
</body>
</html>